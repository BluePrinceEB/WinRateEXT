if _G.WR_COMMON_LOADED then return end;_G.WR_COMMON_LOADED=true;require"MapPositionGOS"require"DamageLib"require"2DGeometry"local a=_G;local b=_G.SDK;local c=b.Orbwalker;local d=b.ObjectManager;local e=b.TargetSelector;local f=b.HealthPrediction;local g=math.huge;local j=math.pi;local k=math.floor;local l=math.ceil;local m=math.sqrt;local n=math.max;local o=math.min;local p=math.lenghtOf;local q=math.abs;local r=math.deg;local s=math.cos;local t=math.sin;local u=math.acos;local v=math.atan;local w=table.contains;local x=table.insert;local y=table.remove;local z=300;local A=myHero.team;local B=z-A;local C=5;local D=8;local E=10;local F=11;local G=21;local H=22;local I=24;local J=29;local K=30;local Vector=Vector;local L=Control.KeyDown;local M=Control.KeyUp;local N=Game.CanUseSpell;local O=Game.Timer;local P=Game.HeroCount;local Q=Game.Hero;local R=Game.MinionCount;local S=Game.Minion;local T=Game.TurretCount;local U=Game.Turret;local V=Game.WardCount;local W=Game.Ward;local X=Game.ObjectCount;local Y=Game.Object;local Z=Game.MissileCount;local _=Game.Missile;local a0=Game.ParticleCount;local a1=Game.Particle;local a2=Draw.Circle;local a3=Draw.Line;local a4=Draw.Color;local a5=Draw.CircleMinimap;local a6=8;local a7=103;local a8=-4;local function a9()local aa=c.Modes;for i=0,#aa do if aa[i]then return i+1 end end;return nil end;local function ab(ac)return d:GetMinions(ac)end;local function ad(ac)return d:GetAllyMinions(ac)end;local function ae(ac)return d:GetEnemyMinions(ac)end;local function af(ac)return d:GetMonsters(ac)end;local function ag(ac)return d:GetHeroes(ac)end;local function ah(ac)return d:GetAllyHeroes(ac)end;local function ai(ac)return d:GetEnemyHeroes(ac)end;local function aj(ac)return d:GetTurrets(ac)end;local function ak(ac)return d:GetAllyTurrets(ac)end;local function al(ac)return d:GetEnemyTurrets(ac)end;local function am(ac)return d:GetOtherMinions(ac)end;local function an(ac)return d:GetOtherAllyMinions(ac)end;local function ao(ac)return d:GetOtherEnemyMinions(ac)end;local function ap(aq)c:OnPreMovement(aq)end;local function ar(aq)c:OnPreAttack(aq)end;local function as(aq)c:OnAttack(aq)end;local function at(aq)c:OnPostAttack(aq)end;local function au(av)Orbwalk:SetMovement(av)end;local function aw(av)Orbwalk:SetAttack(av)end;local function ax(ac,ay)return e:GetTarget(ac or g,ay or 0)end;local function az()c:__OnAutoAttackReset()end;local function Orbwalk()c:Orbwalk()end;local function aA(aB)c.Menu.General.HoldRadius:Value(aB)end;local function aC(aB)c.Menu.General.MovementDelay:Value(aB)end;local function aD(aE)c.ForceTarget=aE end;local function aF(aG)c.ForceMovement=aG end;local function aH(aE,aI)return f:GetPrediction(aE,aI)end;function Ready(aJ)return N(aJ)==0 end;local function aK(aL,aM,aN)local s,t=s(aN),t(aN)local aO=(aL.x-aM.x)*s-(aL.z-aM.z)*t+aM.x;local aP=(aL.z-aM.z)*s+(aL.x-aM.x)*t+aM.z;return Vector(aO,aL.y,aP or 0)end;local function aQ(aR,aS)aS=aS or myHero;aR=aR.pos or aR;aS=aS.pos or aS;local aT,aU=aR.x-aS.x,aR.z-aS.z;return aT*aT+aU*aU end;local function aV(aR,aS)return m(aQ(aR,aS))end;local aW={[ITEM_1]=HK_ITEM_1,[ITEM_2]=HK_ITEM_2,[ITEM_3]=HK_ITEM_3,[ITEM_4]=HK_ITEM_4,[ITEM_5]=HK_ITEM_5,[ITEM_6]=HK_ITEM_6,[ITEM_7]=HK_ITEM_7}local function aX(aY)for i=ITEM_1,ITEM_7 do if myHero:GetItemData(i).itemID==aY then return i,aW[i]end end;return 0 end;local aZ={3340,2049,2301,2302,2303,3711}local function a_()for i=1,#aZ do local b0,b1=aX(aZ[i])if b0~=0 then return b0,b1 end end end;local b2=0;local function b3(aG,b4,b5,b6)b2=(b2+2)%720;local b7,b4,b6,b5=aG or myHero.pos,b4 or 3,b6 or a4(255,255,0,0),b5*2 or 150;local b8,b2,b9=b7+Vector(0,0,b5),b2/360*j,240/360*j;local ba={b7:To2D(),aK(b8,b7,b2):To2D(),aK(b8,b7,b2+b9):To2D(),aK(b8,b7,b2+2*b9):To2D()}for i=1,#ba do for bb=1,#ba do local bc=i~=bb and a3(ba[i].x-3,ba[i].y-5,ba[bb].x-3,ba[bb].y-5,b4,b6)end end end;local function bd(be,bf,bg,b6)local bh,bi=bf-be,be-bf;local bj=(be+bh:Perpendicular2():Normalized()*bg):To2D()local bk=(be+bh:Perpendicular():Normalized()*bg):To2D()local bl=(bf+bi:Perpendicular2():Normalized()*bg):To2D()local bm=(bf+bi:Perpendicular():Normalized()*bg):To2D()a3(bj,bk,3,b6)a3(bk,bl,3,b6)a3(bl,bm,3,b6)a3(bm,bj,3,b6)end;local function bn(aL,aM,bo)local bp,bq,br,bs,bt,bu=bo.x,bo.z,aL.x,aL.z,aM.x,aM.z;local bv=((bp-br)*(bt-br)+(bq-bs)*(bu-bs))/((bt-br)*(bt-br)+(bu-bs)*(bu-bs))local bw={x=br+bv*(bt-br),z=bs+bv*(bu-bs)}local bx=bv<0 and 0 or(bv>1 and 1 or bv)local by=bx==bv;local bz=by and bw or{x=br+bx*(bt-br),z=bs+bx*(bu-bs)}return bz,bw,by end;local function bA(bB,bC,aJ,bD)local bE,bF,bg,aI,bD={},aJ.Speed,aJ.Width+65,aJ.Delay,bD;if not bD then bD=ae(n(aV(bB),aV(bC))+aJ.Range+100)end;for i=1,#bD do local bG=bD[i]local bH=aI and bG:GetPrediction(bF,aI)or bG.pos;if bG and bG.team~=A and bG.dead==false and bG.isTargetable and aQ(bB,bC)>aQ(bB,bH)then local bz,bw,by=bn(bB,bC,bH)if by and aQ(bz,bH)<bg*bg then bE[#bE+1]=bG end end end;return bE end;local function bI(bB,bC,aJ,bD)local bE,bF,bg,aI,bD={},aJ.Speed,aJ.Width+65,aJ.Delay,bD;if not bD then bD=ai(n(aV(bB),aV(bC))+aJ.Range+100)end;for i=1,#bD do local h=bD[i]local bH=aI and h:GetPrediction(bF,aI)or h.pos;if h and h.team~=A and h.dead==false and h.isTargetable and aQ(bB,bC)>aQ(bB,bH)then local bz,bw,by=bn(bB,bC,bH)if by and aQ(bz,bH)<bg*bg then x(bE,h)end end end;return bE end;local function bJ(aE)return aE.maxHealth>5 and aE.health/aE.maxHealth*100 or 100 end;local function bK(aE)return aE.maxMana>0 and aE.mana/aE.maxMana*100 or 100 end;local function bL(aE,bM,aI)local aI=aI or 0;local av=false;local bN=O()for i=1,aE.buffCount do local bO=aE:GetBuff(i)if bO.type==bM and bO.expireTime>=O()and bO.duration>0 then if bO.expireTime>bN then av=true;bN=bO.expireTime end end end;return av,bN end;local function bP(aE,bQ)return GotBuff(aE,bQ)==1 end;local function bR(aE,bQ)return GetBuffData(aE,bQ)end;local function bS(aE,bM)for i=1,aE.buffCount do local bO=aE:GetBuff(i)if bO.type==bM and bO.expireTime>=O()and bO.duration>0 then return bO end end;return nil end;local bT={["Aatrox"]=function(bU,bV)return bP(bU,"aatroxpassivedeath")end,["Fiora"]=function(bU,bV)return bP(bU,"FioraW")end,["Tryndamere"]=function(bU,bV)return bP(bU,"UndyingRage")and(not bV or bU.health<=30)end,["Vladimir"]=function(bU,bV)return bP(bU,"VladimirSanguinePool")end}local function bW(bU,bV)local bX=bT[bU.charName]if bX and bX(bU,bV)then return true end;if bP(bU,"JudicatorIntervention")or(not bV or bJ(bU)<=10)and(bP(bU,"kindredrnodeathbuff")or bP(bU,"ChronoShift")or bP(bU,"chronorevive"))then return true end;return bU.isImmortal end;local function bY(aE,ac)return aE and aE.valid and aE.visible and not aE.dead and aE.isTargetableToTeam and(not ac or aV(aE)<=ac)and(not aE.type==myHero.type or not bW(aE,true))end;local function bZ(aE,bU)local b_=bU and bU.boundingRadius or 0;return aE.range+aE.boundingRadius+b_ end;local function c0(aG,ac)return#HeroesAround(ac,aG,B)end;local function HeroesAround(ac,aG,c1)aG=aG or myHero.pos;local c2=aV(aG)+ac+100;local bE={}local c3=c1==B and ai(c2)or(c1==A and ah(c2)or ag(c2))for i=1,#c3 do local bG=c3[i]if h and bG.team==c1 and h.isValid and h.visible and not h.dead and aV(aG,h.pos)<=ac then bE[#bE+1]=h end end;return bE end;local function c4(ac,aG,c1)aG=aG or myHero.pos;local c2=aV(aG)+ac+100;local bE={}local c5=c1==B and ae(c2)or(c1==A and ad(c2)or ab(c2))for i=1,#c5 do local bG=c5[i]if bG and not bG.dead and aV(aG,bG.pos)<=ac+bG.boundingRadius then bE[#bE+1]=bG end end;return bE end;local function c6(aG,c1)local c7=aj(1000)for i=1,#c7 do if aV(c7[i])<=915 and turret.team==c1 then return true end end end;local function c8(aE,aI)if aE.ms==0 then return true,aE.pos,aE.pos end;local aI=aI or 0;local c9,ca={},O()+aI;for i=1,aE.buffCount do local bO=aE:GetBuff(i)if bO.expireTime>=ca and bO.duration>0 then c9[bO.type]=true end end;if c9[C]or c9[D]or c9[F]or c9[_SLEEP]or c9[H]or c9[I]or c9[_AIRBORNE]then return true end end;local function cb(aE,aS)aS=aS or myHero;aS=aS.pos or aS;local cc=aE.pos-aS;local bm=aE.dir;local cd=180-r(u(cc*bm/(cc:Len()*bm:Len())))if q(cd)<80 then return true end end;local function ce(cf,cg)for i=1,#cf do local bo=cf[i]if cg==bo.handle then return bo end end end;local function ch(cg)return ce(ai(1200),cg)or ce(af(1200),cg)or ce(al(1200),cg)or ce(ae(1200),cg)or ce(ao(1200),cg)end;local function ci()return myHero.dead or bP(myHero,"recall")or Game.IsChatOpen()or ExtLibEvade and ExtLibEvade.Evading==true end;local cj={Joke=HK_ITEM_1,Taunt=HK_ITEM_2,Dance=HK_ITEM_3,Mastery=HK_ITEM_5,Laugh=HK_ITEM_7,Casting=false}local function ck(cl)if not cl or cj.Casting or myHero.attackData.state==STATE_WINDUP then return end;cj.Casting=true;L(HK_LUS)L(cl)DelayAction(function()M(cl)M(HK_LUS)cj.Casting=false end,0.01)end;local function cm(cn,co,cp)local cq=1;for i=2,#co do if aQ(cn,co[i].pos)>aQ(cn,co[cq].pos)then cq=i end end;local cr={}for i=1,#co do if cp and co[i].networkID==cp.networkID or i~=cq then cr[#cr+1]=co[i]end end;return cr end;local function cs(aJ,cp,co)local cn={x=0,z=0,count=0}local ct=co and co[1]and co[1].type==myHero.type;local ac=aJ.Range or 2000;local cu=aJ.Radius or 50;if not co or#co==0 then if cp then return Prediction:GetBestCastPosition(cp,aJ)end;return end;for i=1,#co do if aQ(co[i])<=ac*ac then local cv=ct and Prediction:GetBestCastPosition(co[i],aJ)or co[i].pos;cn.x=cn.x+cv.x;cn.z=cn.z+cv.z;cn.count=cn.count+1 end end;if cp and cp.type~=co[1].type then local cv=ct and Prediction:GetBestCastPosition(cp,aJ)or co[i].pos;cn.x=cn.x+cv.x;cn.z=cn.z+cv.z;cn.count=cn.count+1 end;cn.x=cn.x/cn.count;cn.z=cn.z/cn.count;local cw=0;for i=1,#co do local cx=co[i].boundingRadius;if aQ(cn,co[i].pos)-cx*cx<cu*cu then cw=cw+1 end end;local cy=Vector(cn.x,myHero.pos.y,cn.z)if cw==#co then return cy,cw else return cs(aJ,cp,cm(cn,co))end end;local function cz(aJ,cp,bD)startPos=aJ.From.pos or myHero.pos;local cA=bD[1].type==myHero.type;local cB=cs(aJ,cp,bD)local cC=startPos+(cB-startPos):Normalized()*aJ.Range;local cD=cA and#bI(startPos,cC,aJ,bD)or#bA(startPos,cC,aJ,bD)return cC,cD end;local function cE(aJ)local c5=ae(aJ.Range+aJ.Radius)if#c5==0 then return nil,0 end;return cz(aJ,nil,c5)end;local function cF(aJ)local c5=ae(aJ.Range+aJ.Radius)if#c5==0 then return nil,0 end;return cs(aJ,nil,c5)end;class"Spell"function Spell:__init(cG)self.Slot=cG.Slot;self.Range=cG.Range or g;self.Delay=cG.Delay or 0.25;self.Speed=cG.Speed or g;self.Radius=cG.Radius or cG.Width or 0;self.Width=cG.Width or cG.Radius or 0;self.From=cG.From or myHero;self.Collision=cG.Collision or false;self.Type=cG.Type or"Press"return self end;function Spell:SetRange(aB)self.Range=aB end;function Spell:SetRadius(aB)self.Radius=aB end;function Spell:SetSpeed(aB)self.Speed=aB end;function Spell:SetFrom(aB)self.From=aB end;function Spell:IsReady()return N(self.Slot)==READY end;function Spell:CanCast(aE,ac,cH)local cH=cH or self.From.pos;local ac=ac or self.Range;return aE and aE.valid and aE.visible and not aE.dead and(not ac or aV(cH,aE)<=ac)end;function Spell:GetPrediction(bU)return Prediction:GetBestCastPosition(bU,self)end;function Spell:GetBestLinearCastPos(cp,co)return cz(self,cp,co)end;function Spell:GetBestCircularCastPos(cp,co)return cs(self,cp,co)end;function Spell:GetBestLinearFarmPos()return cE(self)end;function Spell:GetBestCircularFarmPos()return cF(self)end;function Spell:GetDamage(bU,cI)local cJ=self:SlotToString()return getdmg(cJ,bU,self.From,cI or 1)end;function Spell:OnDash(bU)local cK,cL,Pos=Prediction:IsDashing(bU,self)if self.Collision then local cM=#bA(self.From.pos,Pos,self)>0;if cM then return end;return cK,cL,Pos end;return cK,cL,Pos end;function Spell:OnImmobile(bU)local cN,cO,cP=Prediction:IsImmobile(bU,self)if self.Collision then local cM=#bA(self.From.pos,Pos,self)>0;if cM then return end;return cN,cO,cP end;return cN,cO,cP end;function Spell:SlotToHK()return({[_Q]=HK_Q,[_W]=HK_W,[_E]=HK_E,[_R]=HK_R,[SUMMONER_1]=HK_SUMMONER_1,[SUMMONER_2]=HK_SUMMONER_2})[self.Slot]end;function Spell:SlotToString()return({[_Q]="Q",[_W]="W",[_E]="E",[_R]="R"})[self.Slot]end;function Spell:Cast(cQ)if not self:IsReady()or ci()then return end;local cJ=self:SlotToHK()if self.Type=="Press"then L(cJ)return M(cJ)end;local aG=cQ.x and cQ;local cR=cQ.health and cQ;if self.Type=="AOE"then local cS,cT=self:GetBestCircularCastPos(cR,ai(self.Range+self.Radius))aG=cT>=2 and cS or aG end;if cR and not cR.pos:To2D().onScreen then return elseif aG and not aG:To2D().onScreen then aG=myHero.pos:Extended(aG,200)if self.Type=="AOE"or not aG:To2D().onScreen then return end end;return Control.CastSpell(cJ,cR or aG)end;function Spell:CastToPred(bU,cU)local cV,cW,cX=self:GetPrediction(bU)if cV and cX>=cU then return self:Cast(cV)end end;function Spell:DrawDmg(cY,cZ,c_,cI)local d0=cY.hpBar;if d0.onScreen then local d1=(self:IsReady()and 1 or 0)*self:GetDamage(cY,cI)*(cZ or 1)+(c_ or 0)local d2=n(0,cY.health-d1)/cY.maxHealth;local d3=d0.x+22+a7*cY.health/cY.maxHealth;local d4=d0.x+22+d2*100;a3(d4,d0.y+a8,d3,d0.y+a8,10,Draw.Color(255,235,103,25))end end;function Spell:Draw(d5,d6,d7)if self.Range and self.Range~=g then if self:IsReady()then a2(self.From.pos,self.Range,5,a4(255,d5,d6,d7))else a2(self.From.pos,self.Range,5,a4(80,d5,d6,d7))end;return true end end;function Spell:DrawMap(d5,d6,d7)if self.Range and self.Range~=g then if self:IsReady()then a5(self.From.pos,self.Range,5,a4(255,d5,d6,d7))else a5(self.From.pos,self.Range,5,a4(80,d5,d6,d7))end;return true end end;print("[WR] | Common Loaded")